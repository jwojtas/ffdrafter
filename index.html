<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Fantasy Draft Simulator</title>
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 text-gray-900">
<div id="root"></div>

<script type="text/babel">

const defaultTeams = ["Team 1","Team 2","Team 3","Team 4","Team 5","Team 6","Team 7","Team 8","Team 9","Team 10","Team 11","Team 12"];

const startersRequired = { QB:1,RB:2,WR:2,TE:1,FLEX:1,DST:1,K:1 };
const maxPlayers = { QB:4,RB:8,WR:8,TE:3,FLEX:1,DST:3,K:3,BE:7 };

const normalizePos = (pos) => {
  if (!pos) return "";
  const p = pos.trim().toUpperCase();
  if (p === "DEF" || p === "D") return "DST";
  if (p === "PK" || p === "PLACEKICKER" || p === "PLACE KICKER") return "K";
  return p;
};

function generateSnakeOrder(numTeams, totalRounds) {
  let order = [];
  for (let round = 0; round < totalRounds; round++) {
    let roundOrder = Array.from({ length: numTeams }, (_, i) => i);
    if (round % 2 !== 0) roundOrder.reverse();
    order.push(...roundOrder);
  }
  return order;
}

function suggestPick(players, teamNeeds) {
  let available = players.filter(p => !p.drafted);
  let needed = [];
  for (let pos of ["QB","RB","WR","TE","FLEX","DST","K"]) {
    if (teamNeeds[pos] > 0) {
      if (pos === "FLEX") {
        needed.push(...available.filter(p => ["RB","WR","TE"].includes(normalizePos(p.pos))));
      } else {
        needed.push(...available.filter(p => normalizePos(p.pos) === pos));
      }
    }
  }
  let sorted = (needed.length ? needed : available).sort((a,b) => a.adp - b.adp);
  return sorted[0];
}

function ManualPick({ players, onPick }) {
  const [query, setQuery] = React.useState("");
  const available = players.filter(p => !p.drafted);
  const filtered = available.filter(p =>
    p.name.toLowerCase().includes(query.toLowerCase())
  );

  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={e => setQuery(e.target.value)}
        placeholder="Search player..."
        className="border px-2 py-1 rounded w-full mb-2"
      />
      <select 
        size={6}
        className="w-full border rounded"
        value=""
        onChange={(e) => {
          const player = available.find(p => p.name === e.target.value);
          if (player) onPick(player);
        }}
      >
        {filtered.map((p, i) => (
          <option key={i} value={p.name}>
            {p.name} ({normalizePos(p.pos)}) â€“ ADP {p.adp}
          </option>
        ))}
      </select>
    </div>
  );
}

function App() {
  const [players, setPlayers] = React.useState([]);
  const [teams, setTeams] = React.useState([]);
  const [draftOrder, setDraftOrder] = React.useState([]);
  const [currentPickIndex, setCurrentPickIndex] = React.useState(0);
  const [numTeams, setNumTeams] = React.useState(8);
  const [draftStarted, setDraftStarted] = React.useState(false);
  const [loading, setLoading] = React.useState(false);
  const [error, setError] = React.useState("");
  const [userPickPosition, setUserPickPosition] = React.useState(0);
  const [manualAllTeams, setManualAllTeams] = React.useState(false);
  const [fastDraft, setFastDraft] = React.useState(false);

  const fetchADP = async () => {
    setLoading(true);
    setError("");
    try {
      const res = await fetch("/.netlify/functions/adp");
      if (!res.ok) throw new Error("Failed to fetch ADP");
      const data = await res.json();

      const mapped = (data.players || [])
  .map(p => ({
    name: p.player_name || p.name,
    pos: normalizePos(p.position || p.pos),
    adp: Number(p.adp) || 999,
    drafted: false
  }));

console.log("Mapped players:", mapped.length);
setPlayers(mapped);
    } catch (e) {
      console.error(e);
      setError("Could not fetch ADP data.");
    }
    setLoading(false);
  };

  const startDraft = () => {
    let draftTeams = [];
    for (let i = 0; i < numTeams; i++) {
      draftTeams.push({
        name: defaultTeams[i] || `Team ${i+1}`,
        roster: {QB:[],RB:[],WR:[],TE:[],FLEX:[],DST:[],K:[],BE:[]}
      });
    }
    setTeams(draftTeams);
    const order = generateSnakeOrder(numTeams, 16);
    setDraftOrder(order);
    setCurrentPickIndex(0);
    setDraftStarted(true);
  };

  const makePick = (manualPlayer = null) => {
  if (currentPickIndex >= draftOrder.length) return;
  const pickTeamIndex = draftOrder[currentPickIndex];
  const team = teams[pickTeamIndex];

  let pick = manualPlayer;

  if (!pick) {
    const teamNeeds = {};
    for (let pos of ["QB","RB","WR","TE","FLEX","DST","K"]) {
      teamNeeds[pos] = Math.max(0, startersRequired[pos] - (team.roster[pos]?.length || 0));
    }

    const teamPicksMade = Object.values(team.roster).flat().length;
    const teamPicksLeft = 16 - teamPicksMade;

    const needsDST = (team.roster.DST?.length || 0) === 0;
    const needsK   = (team.roster.K?.length   || 0) === 0;

    // ðŸ”’ FORCE logic: if they won't have enough picks left, draft K/DST now
    if (needsDST && teamPicksLeft <= (needsK ? 2 : 1)) {
      pick = players.find(p => !p.drafted && normalizePos(p.pos) === "DST");
    }
    if (!pick && needsK && teamPicksLeft <= (needsDST ? 2 : 1)) {
      pick = players.find(p => !p.drafted && normalizePos(p.pos) === "K");
    }

    // Normal suggestion if no forced pick
    if (!pick) {
      pick = suggestPick(players, teamNeeds);
    }
  }

  if (!pick) return;
  pick.drafted = true;

  const pos = normalizePos(pick.pos);
  if (!team.roster[pos]) team.roster[pos] = [];

  if (team.roster[pos].length < (startersRequired[pos] || 0)) {
    team.roster[pos].push(pick);
  } else if (["RB","WR","TE"].includes(pos) && team.roster.FLEX.length < startersRequired.FLEX) {
    team.roster.FLEX.push(pick);
  } else if (team.roster[pos].length < (maxPlayers[pos] || 99)) {
    team.roster[pos].push(pick);
  } else {
    team.roster.BE.push(pick);
  }

  const updatedTeams = [...teams];
  updatedTeams[pickTeamIndex] = team;
  setTeams(updatedTeams);
  setCurrentPickIndex(currentPickIndex + 1);
};

  const currentTeamIndex = draftOrder[currentPickIndex];
  const currentTeam = currentTeamIndex!=null?teams[currentTeamIndex]:null;
  const round = Math.floor(currentPickIndex / numTeams) + 1;
  const teamNeeds = currentTeam ? {
    QB: Math.max(0, startersRequired.QB-(currentTeam.roster.QB?.length||0)),
    RB: Math.max(0, startersRequired.RB-(currentTeam.roster.RB?.length||0)),
    WR: Math.max(0, startersRequired.WR-(currentTeam.roster.WR?.length||0)),
    TE: Math.max(0, startersRequired.TE-(currentTeam.roster.TE?.length||0)),
    FLEX: Math.max(0, startersRequired.FLEX-(currentTeam.roster.FLEX?.length||0)),
    DST: Math.max(0, startersRequired.DST-(currentTeam.roster.DST?.length||0)),
    K: Math.max(0, startersRequired.K-(currentTeam.roster.K?.length||0))
  } : {};
  const suggestedPick = currentTeam ? suggestPick(players, teamNeeds) : null;
  const draftComplete = currentPickIndex >= draftOrder.length;

  React.useEffect(() => {
    if (!draftStarted || draftComplete) return;
    if (currentTeamIndex == null) return;
    if (currentTeamIndex !== userPickPosition && !manualAllTeams) {
      const delay = fastDraft ? 0 : 1000;
      const timer = setTimeout(() => makePick(), delay);
      return () => clearTimeout(timer);
    }
  }, [currentPickIndex, draftStarted, fastDraft]);

  // âœ… Fixed grade function
  const gradeTeam = (team) => {
    if (!team || !team.roster) return 0;

    const players = Object.values(team.roster).flat();
    if (players.length === 0) return 0;

    const totalADP = players.reduce((sum, p) => {
      const val = typeof p.adp === "number" && !isNaN(p.adp) ? p.adp : 999;
      return sum + val;
    }, 0);

    const posScore = Object.entries(startersRequired).reduce((sum, [pos, req]) => {
      const have = (team.roster[pos] || []).length;
      return sum + Math.min(have / (req || 1), 1);
    }, 0);

    const adpScore = ((players.length * teams.length * 16) - totalADP) / (players.length * teams.length * 16);
    const grade = (posScore / Object.keys(startersRequired).length) * 50 + Math.max(0, adpScore) * 50;

    return grade.toFixed(1);
  };

  return (
    <div className="max-w-6xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-4">Fantasy Draft Simulator - Full Roster</h1>

      {!draftStarted && (
        <div className="mb-6">
          <label className="mr-2"># of Teams:</label>
          <select value={numTeams} onChange={e=>setNumTeams(Number(e.target.value))} className="border rounded px-2 py-1">
            <option value={8}>8</option>
            <option value={10}>10</option>
            <option value={12}>12</option>
          </select>
          <label className="ml-4 mr-2">Your Draft Position:</label>
          <select value={userPickPosition} onChange={e=>setUserPickPosition(Number(e.target.value))} className="border rounded px-2 py-1">
            {Array.from({length:numTeams},(_,i)=><option key={i} value={i}>{i+1}</option>)}
          </select>
          <label className="ml-4">
            <input 
              type="checkbox" 
              checked={manualAllTeams} 
              onChange={e => setManualAllTeams(e.target.checked)} 
              className="mr-1"
            />
            I will pick for all teams
          </label>
          <label className="ml-4">
            <input 
              type="checkbox" 
              checked={fastDraft} 
              onChange={e => setFastDraft(e.target.checked)} 
              className="mr-1"
            />
            Fast Draft (CPU picks instantly)
          </label>
          <button onClick={fetchADP} className="ml-4 px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Load Players</button>
          <button onClick={startDraft} className="ml-4 px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700">Start Draft</button>
          {loading && <span className="ml-2">Loading...</span>}
          {error && <p className="text-red-500 mt-2">{error}</p>}
        </div>
      )}

      {draftStarted && !draftComplete && currentTeam && (
        <div className="mb-6">
          <h2 className="text-xl font-semibold">
            Round {round}/16 â€“ Current Pick: {currentTeam.name}
          </h2>
          <p className="mb-2">
            Suggested Pick: {suggestedPick ? `${suggestedPick.name} (${normalizePos(suggestedPick.pos)})` : "No pick available"}
          </p>

          {(currentTeamIndex === userPickPosition || manualAllTeams) ? (
            <div>
              <button 
                onClick={() => makePick()} 
                className="mb-4 px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700"
              >
                Draft Suggested Pick
              </button>
              <ManualPick players={players} onPick={(player) => makePick(player)} />
            </div>
          ) : (
            <p className="text-gray-600">Auto-picking...</p>
          )}
        </div>
      )}

      {draftStarted && (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
          {(() => {
            const orderedTeams = [
              teams[userPickPosition],
              ...teams.slice(0, userPickPosition),
              ...teams.slice(userPickPosition + 1)
            ];
            return orderedTeams.map((team, i) => {
              const bench = [...team.roster.BE];
              const isUser = team === teams[userPickPosition];
              return (
                <div
                  key={i}
                  className={`bg-white p-4 rounded-xl shadow ${
                    isUser ? "border-2 border-blue-500" : ""
                  }`}
                >
                  <h3 className="font-bold mb-2">
                    {team?.name || `Team`} {isUser ? "(You)" : ""}
                  </h3>
                  {["QB", "RB", "WR", "TE", "FLEX", "DST", "K"].map((pos) => {
                    const arr = team.roster[pos] || [];
                    const starters = arr.slice(0, startersRequired[pos] || 0);
                    const extras = arr.slice(startersRequired[pos] || 0);
                    bench.push(...extras);
                    let color = pos === "FLEX" ? "text-green-600 font-semibold" : "";
                    return (
                      <div key={pos} className={`${color} mb-1`}>
                        <strong>{pos}:</strong> {starters.map((p) => p.name).join(", ")}
                      </div>
                    );
                  })}
                  <div className="text-gray-500 italic mb-1">
                    <strong>BE:</strong> {bench.map((p) => p.name).join(", ")}
                  </div>
                </div>
              );
            });
          })()}
        </div>
      )}

      {draftComplete && teams[userPickPosition] && (
        <div className="bg-green-100 p-4 rounded-xl">
          <h2 className="text-xl font-bold mb-2">Draft Complete!</h2>
          <p>Your Team Grade: {gradeTeam(teams[userPickPosition])} / 100</p>
          <p>Grades for Other Teams:</p>
          <ul>
            {teams.map((t,i)=>(
              <li key={i}>{t?.name || `Team ${i+1}`}: {gradeTeam(t)}{i===userPickPosition?' (You)':''}</li>
            ))}
          </ul>
        </div>
      )}
    </div>
  );
}

const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(<App />);
</script>
</body>
</html>
